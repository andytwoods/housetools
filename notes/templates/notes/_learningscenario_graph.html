{% extends 'base.html' %}
{% load static %}

{% block javascript %}
  {{ block.super }}
  <script src="{% static "js/chart.js" %}"></script>

{% endblock javascript %}

{% block title %}
  Practice results
{% endblock title %}

{% block content %}

  <title>Practice results</title>

  {{ progress|json_script:"progress-data" }}
  {{ rt_per_sk|json_script:"rt_per_sk-data" }}
  <canvas id="staveChart" width="800" height="400"></canvas>
  <script>
    document.addEventListener("DOMContentLoaded", function () {
      const progress_data = JSON.parse(
        document.getElementById("progress-data").textContent
      );
      const rt_per_sk = JSON.parse(
        document.getElementById("rt_per_sk-data").textContent
      );

      function median(numbers) {
        numbers = numbers.map(Number);
        const sorted = Array.from(numbers).sort((a, b) => a - b);
        const middle = Math.floor(sorted.length / 2);

        if (sorted.length % 2 === 0) {
          return (sorted[middle - 1] + sorted[middle]) / 2;
        }
        return sorted[middle];
      }

      // Prepare scatter plot data from progress_data
      let data = [];
      let staveLines = [];

      for (let i = 0; i < progress_data.length; i++) {
        const pd = progress_data[i];
        const rt_log = pd.reaction_time_log;

        if (!rt_log || rt_log.length === 0) continue; // Skip if no reaction time data found
        let rt = median(rt_log);
        let note_id = pd.note + "/" + pd.octave;

        data.push({note: note_id, time: rt});
        staveLines.push(note_id);
      }

      // Calculate note position for the x-axis
      const notePositions = staveLines.reduce((acc, note, index) => {
        acc[note] = index * 20 + 50; // X positions for each note, evenly spaced
        return acc;
      }, {});

      // Extract reaction times from progress and rt_per_sk
      const reactionTimesProgress = data.map((d) => d.time);
      const reactionTimesSkills = Object.values(rt_per_sk)
        .flat()
        .map((d) => d.rt);

      const allReactionTimes = [...reactionTimesProgress, ...reactionTimesSkills];
      const maxTime = Math.max(...allReactionTimes);

      const createBand = (skillLevel, color, stack, fill_info) => {
        const skillData = rt_per_sk[skillLevel];

        if (!skillData || skillData.length === 0) return null;

        // Calculate the minimum and maximum x-axis positions
        const minX = Math.min(...Object.values(notePositions)) - 10; // Add padding if needed
        const maxX = Math.max(...Object.values(notePositions)) + 10; // Add padding if needed

        // Prepare band data
        const bandData = staveLines.map((note) => {
          const matchingNote = skillData.find((d) => `${d.note}/${d.octave}` === note);
          return {
            x: notePositions[note],
            y: matchingNote ? matchingNote.rt : null,
            stack: stack, // Ensure stacking for the band
          };
        });

        // Filter only valid points (y !== null)
        const validPoints = bandData.filter((point) => point.y !== null);

        // Helper function for linear interpolation
        const interpolate = (x, x1, y1, x2, y2) => {
          return y1 + ((y2 - y1) / (x2 - x1)) * (x - x1);
        };

        // Interpolate the y value for minX
        if (validPoints.length > 1) {
          const [point1, point2] = validPoints.slice(0, 2); // Nearest two points for the start
          const minY = interpolate(minX, point1.x, point1.y, point2.x, point2.y);

          // Add the interpolated start point
          validPoints.unshift({x: minX, y: minY});
        }

        // Interpolate the y value for maxX
        if (validPoints.length > 1) {
          const [point1, point2] = validPoints.slice(-2); // Nearest two points for the end
          const maxY = interpolate(maxX, point1.x, point1.y, point2.x, point2.y);

          // Add the interpolated end point
          validPoints.push({x: maxX, y: maxY});
        }

        return {
          label: skillLevel.charAt(0).toUpperCase() + skillLevel.slice(1),
          data: validPoints,
          borderColor: color,
          backgroundColor: color,
          borderWidth: 1,
          fill: fill_info, // Fill the band
          stack: stack, // Stack the band
          pointRadius: 0,
          type: "line",
          tension: 0.4,
          order: 100,
        };
      };
      // Create all bands for the skill levels
      const bands = [
        createBand("beginner", "rgba(102, 192, 168, 0.6)", "beginner-stack", 1),
        createBand("intermediate", "rgba(255, 217, 47, 0.6)", "intermediate-stack", 'start'),
        createBand("advanced", "rgba(213, 94, 0, 0.6)", "advanced-stack", 'start', 'start'),
      ].filter((b) => b !== null);

      const color = "rgba(255, 99, 132, 1)";
      // Prepare the chart data
      const chartData = {
        labels: data.map((d) => `${d.note}`),
        datasets: [
          ...bands, // Zones (bands) appear first
          {
            label: "Your Data",
            borderColor: "rgba(255, 99, 132, 1)", // Point color
            backgroundColor: "rgba(255, 99, 132, 1)", // Point fill color
            data: data.map((d) => ({
              x: notePositions[d.note],
              y: d.time,
            })),
            pointRadius: 10, // Size of points
            pointHoverRadius: 12, // Size on hover
            type: "scatter", // Scatter plot for points
            order: 1, // Ensures it stays on top (optional, but clarifies intention)
          },
        ],
      };

      // Add plugin to render labels below circles
      const addPointLabelsPlugin = {
        id: "addPointLabels",
        afterDatasetDraw(chart, args, options) {
          const {ctx} = chart;
          const datasetIndex = chart.data.datasets.length - 1; // Scatter dataset
          const meta = chart.getDatasetMeta(datasetIndex);

          meta.data.forEach((point, index) => {
            const {x, y} = point.tooltipPosition();
            const label = chart.data.labels[index];
            ctx.save();
            ctx.font = "12px Arial";
            ctx.fillStyle = "#000"; // Label color
            ctx.textAlign = "center";
            ctx.textBaseline = "top";
            ctx.fillText(label, x, y + 12); // Position label below the circle
            ctx.restore();
          });
        },
      };

      // Chart configuration
      const config = {
        type: "scatter",
        data: chartData,
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: true,
            },
          },
          scales: {
            x: {
              title: {
                display: true,
                text: "Notes",
              },
              ticks: {
                callback: function (value) {
                  const note = Object.keys(notePositions).find(
                    (note) => notePositions[note] === value
                  );
                  return note || "";
                }
              },
              min: Math.min(...Object.values(notePositions)) - 10,
              max: Math.max(...Object.values(notePositions)) + 10,
            },
            y: {
              title: {
                display: true,
                text: "Reaction Time (ms)",
              },
              stacked: true, // Ensure stacking
              min: 0,
              max: maxTime + 50,
            },
          },
        },
        plugins: [addPointLabelsPlugin],
      };

      // Render the chart
      const ctx = document.getElementById("staveChart").getContext("2d");
      new Chart(ctx, config);
    });
  </script>

{% endblock content %}
