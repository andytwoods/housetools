{% extends 'base.html' %}
{% load static %}

{% block css %}
  {{ block.super }}

  <style>

    .draggable {
      touch-action: none;
      user-select: none;
    }

    #sheet {
      width: 100%; /* Container takes full width */
      height: 250px; /* Define the height for the stave */

      display: flex;
      justify-content: center; /* Horizontally center the stave */
      align-items: center; /* Vertically center the stave */
    }

    /* Ensure the SVG dynamically adjusts */
    svg {
      display: block; /* Ensure no extra spaces due to inline SVG behavior */
    }

  </style>
{% endblock css %}

{% block javascript %}
  {{ block.super }}
  <script src="{% static 'js/vexflow.js' %}"></script>
{% endblock javascript %}

{% block title %}
  Child Page Title
{% endblock %}

{% block content %}

  <style>
    .mw-md-75 {
      max-width: 100%;
    }

    @media (min-width: 768px) {
      .mw-md-75 {
        max-width: 75%;
      }
    }

    @media (min-width: 992px) {
      .mw-md-75 {
        max-width: 50%;
      }
    }
  </style>

  <div id='error-message'
       class="position-fixed start-50 translate-middle-x text-center bg-danger text-white p-2 rounded shadow"
       style="z-index: 1050; top: 5%; display: none;">
    <h2>m i s t a k e</h2>
    <p id="correct-answer"></p>
  </div>

  <div class="card mw-md-75">
    <div class="card-header text-center">
      <h5>Trumpet Note/Fingering Learning Tool</h5>
    </div>

    <div class="card-body position-relative">
      <div id="counter" class="position-absolute top-0 start-0 p-2 m-2">
        <span id="counter-value"></span>
      </div>
      <div class="row mt-5">
        <div class="col-9 align-self-center text-center">

          <div id="sheet"></div>
        </div>
        <div id="right-of-sheet-placeholder"></div>

      </div>
      {% include 'notes/instruments/trumpet.html' %}

    </div>
  </div>



  {{ progress|json_script:"progress-data" }}


  <script>


    function sendListToBackend(list) {

      // Sending the POST request to the backend
      const response = fetch("{% url 'practice-data' learningscenario_id=learningscenario_id %}", {
        method: 'POST', // HTTP method
        headers: {
          'Content-Type': 'application/json',
          'X-CSRFToken': "{{ csrf_token }}"
        },
        body: JSON.stringify({data: list}) // Convert the list to JSON format
      });

    }
  </script>
  <script>

    const VF = Vex.Flow;  // Reference VexFlow library
    const div = document.getElementById("sheet");
    const containerWidth = div.clientWidth;
    const staveWidth = 200; //

    // Initialize VexFlow renderer
    const renderer = new VF.Renderer(div, VF.Renderer.Backends.SVG);
    renderer.resize(containerWidth, 200);  // Resize the SVG

    const context = renderer.getContext();  // Get the rendering context

    const startX = (containerWidth - staveWidth) / 2; // Calculate the starting point for centering
    const stave = new VF.Stave(startX, 40, staveWidth);
    stave.addClef("treble");  // Add a Treble Clef
    stave.setContext(context); // Attach the context to the stave
    stave.draw(context);       // Draw the stave


    function updateNote(newNote) {
      console.log(newNote)
      // Clear the SVG context to remove previous notes
      renderer.getContext().svg.innerHTML = "";

      // Redraw the stave
      stave.setContext(context);
      stave.draw();

      let noteX = staveWidth / 2; // Calculate the horizontal center of the stave

      // Create a single note using the passed `newNote`
      const note = new VF.StaveNote({keys: [newNote], duration: "q", align_center: true})


      // Add notes to a voice and render
      const voice = new VF.Voice({num_beats: 1, beat_value: 4});
      voice.addTickables([note]);
      if (newNote.indexOf('#') !== -1 || newNote.indexOf('b') !== -1) {
        VF.Accidental.applyAccidentals([voice], `D`);
        noteX += 15;
      }
      new VF.Formatter().joinVoices([voice]).format([voice], noteX);
      voice.draw(context, stave);
    }

  </script>

  <script>

    const countdown_manager = (function () {
      let api = {};

      let remainingTime;

      // Update the counter value immediately when starting
      const counterSpan = document.getElementById("counter-value");

      api.start = function (durationInSeconds) {
        if (remainingTime !== undefined) return;
        remainingTime = durationInSeconds;
        counterSpan.textContent = remainingTime;

        const intervalId = setInterval(() => {
          remainingTime--;
          counterSpan.textContent = remainingTime;

          // Check if timer is finished
          if (remainingTime <= 0) {
            clearInterval(intervalId);
            counterSpan.textContent = "Time's up!";
          }
        }, 1000);

      }

      return api;
    }());

    document.addEventListener("DOMContentLoaded", function () {
      const progress_data = JSON.parse(
        document.getElementById('progress-data').textContent
      );

      trial_manager.setProgress(progress_data);
      trial_manager.start();
    });

    const trial_manager = (function () {
      let api = {};

      let current_note;
      let progress_data;

      const timer = (function () {
        let api = {};
        let start = undefined;

        api.start = function () {
          start = performance.now();
        }
        api.stop = function () {
          const rt = performance.now() - start;
          return rt.toFixed(0)
        }

        return api;
      }());

      const error_message_manager = (function () {
        let api = {};
        let callback;
        const error_message_el = document.getElementById('error-message');
        const correct_answer_el = document.getElementById('correct-answer');

        api.stop = function () {
          error_message_el.style.display = 'none';
          callback();
          callback = undefined;
        }

        api.start = function (message, _callback) {
          callback = _callback;
          correct_answer_el.innerText = message;
          error_message_el.style.display = 'block';
        }

        return api;
      }());


      let locked = false;

      api.answer = function (answer, mistake_message) {
        if (locked) {
          error_message_manager.stop();
          return;
        }
        countdown_manager.start(120);
        locked = true;
        const rt = timer.stop();
        current_note['reaction_time_log'].push(rt);
        current_note['correct'].push(answer);
        current_note['n'] += 1;

        if (answer === true) {
          api.start();
          locked = false;
        } else error_message_manager.start(mistake_message, () => {
          api.start();
          locked = false;
        });
      }

      api.setProgress = function (_progress_data) {
        progress_data = _progress_data;
        progress_data.forEach(note => {
          note['reaction_time_log'] = [];
          note['correct'] = [];
        })
      }


      function sortAndRandomizeByN() {
        return progress_data.slice().sort((a, b) => {
          if (a.n !== b.n) {
            return a.n - b.n;
          }
          return Math.random() - 0.5;
        });
      }

      function parse_note(note) {
        let note_str = note['note'];
        note_str = note_str.charAt(0);
        switch (note['alter']) {
          case 1:
            note_str += '#';
            break;
          case -1:
            note_str += 'b';
            break;
          case 2:
            note_str += '##';
            break;
          case -2:
            note_str += 'bb';
            break;
        }
        note_str += '/' + note['octave'];
        return note_str;
      }

      api.start = function () {
        current_note = sortAndRandomizeByN()[0];
        const parsed_note = parse_note(current_note);
        document.current_note = parsed_note;
        timer.start();
        updateNote(parsed_note);
      }


      return api;
    }());
  </script>
{% endblock content %}
