{% extends 'base.html' %}
{% load static %}

{% block css %}
  {{ block.super }}

  <style>

    .draggable {
      touch-action: none;
      user-select: none;
    }

    #sheet {
      width: 100%; /* Container takes full width */
      height: 250px; /* Define the height for the stave */
      border: 1px solid #ccc; /* Optional: Add a border */
      display: flex;
      justify-content: center; /* Horizontally center the stave */
      align-items: center; /* Vertically center the stave */
    }

    /* Ensure the SVG dynamically adjusts */
    svg {
      display: block; /* Ensure no extra spaces due to inline SVG behavior */
    }

    .draggable-box {
      display: flex;
      flex-direction: column; /* Stack buttons vertically */
      justify-content: space-around; /* Space evenly between buttons */
      align-items: center; /* Center-align buttons horizontally in the container */
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 150px; /* Adjust width for vertical layout */
      height: 300px; /* Make the box taller to fit vertical buttons */
      background: #fff;
      border: 2px solid #ccc;
      padding: 10px;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      cursor: grab;
    }

    .drag-handle {
      width: 100%;
      top: -30px;
      left: -30px;
      cursor: grab; /* Show a grab cursor */
      text-align: left;
      border-radius: 6px 6px 0 0; /* Rounded corners only at the top */
    }

    .trumpet {
      width: 90%;
      height: 30%;
      margin: 10px;
      border-radius: 50%;
    }

    /* Buttons inside the box */
    .draggable-box button {
      padding: 10px 20px;
      border: none;
      background-color: #3478f6;
      color: #fff;
      font-size: 16px;
      cursor: pointer;
    }

    .draggable-box button:hover {
      top: -30px;
      left: -30px;
    }

    /* Resize/rotate handles (for resizing and rotating the box) */
    .resize-handle {
      width: 10px;
      height: 10px;
      position: absolute;
    }

    .resize-handle.br { /* Bottom-Right handle */
      bottom: -5px;
      right: -5px;
      cursor: se-resize;
    }

    .resize-handle.rotate { /* Rotate handle */
      top: -30px;
      left: 50%;
      transform: translateX(-50%);
      width: 15px;
      height: 15px;
      border-radius: 50%;
      cursor: grab;
    }
  </style>
{% endblock css %}

{% block javascript %}
  {{ block.super }}
  <script src="{% static 'js/vexflow.js' %}"></script>
{% endblock javascript %}

{% block title %}
  Child Page Title
{% endblock %}

{% block content %}
  <h2>Practice</h2>

  <div class="row">
    <div class="col-12">
      <h5>Trumpet note/fingering learning tool</h5>
    </div>
    <div class="col-12 align-self-center text-center">

      <div id="sheet"></div>
    </div>

  </div>

  {% include 'notes/instruments/trumpet.html' %}


  {{ progress|json_script:"progress-data" }}


  <script>


    function sendListToBackend(list) {

      // Sending the POST request to the backend
      const response = fetch("{% url 'practice-data' learningscenario_id=learningscenario_id %}", {
        method: 'POST', // HTTP method
        headers: {
          'Content-Type': 'application/json',
          'X-CSRFToken': "{{ csrf_token }}"
        },
        body: JSON.stringify({data: list}) // Convert the list to JSON format
      });

    }
  </script>
  <script>

    const VF = Vex.Flow;  // Reference VexFlow library
    const div = document.getElementById("sheet");
    const containerWidth = div.clientWidth;
    const staveWidth = 200; //

    // Initialize VexFlow renderer
    const renderer = new VF.Renderer(div, VF.Renderer.Backends.SVG);
    renderer.resize(containerWidth, 200);  // Resize the SVG

    const context = renderer.getContext();  // Get the rendering context

    const startX = (containerWidth - staveWidth) / 2; // Calculate the starting point for centering
    const stave = new VF.Stave(startX, 40, staveWidth);
    stave.addClef("treble");  // Add a Treble Clef
    stave.setContext(context); // Attach the context to the stave
    stave.draw(context);       // Draw the stave


    function updateNote(newNote) {
      console.log(newNote)
      // Clear the SVG context to remove previous notes
      renderer.getContext().svg.innerHTML = "";

      // Redraw the stave
      stave.setContext(context);
      stave.draw();

      let noteX = staveWidth / 2; // Calculate the horizontal center of the stave

      // Create a single note using the passed `newNote`
      const note = new VF.StaveNote({keys: [newNote], duration: "q", align_center: true})


      // Add notes to a voice and render
      const voice = new VF.Voice({num_beats: 1, beat_value: 4});
      voice.addTickables([note]);
      if(newNote.indexOf('#') !== -1 || newNote.indexOf('b') !== -1) {
        VF.Accidental.applyAccidentals([voice], `D`);
        noteX += 15;
      }
      new VF.Formatter().joinVoices([voice]).format([voice], noteX);
      voice.draw(context, stave);
    }

  </script>

  <script>

    document.addEventListener("DOMContentLoaded", function () {
      const progress_data = JSON.parse(
        document.getElementById('progress-data').textContent
      );

      trialmananger.setProgress(progress_data);
      trialmananger.start();
    });

    const trialmananger = (function () {
      let api = {};

      let current_note;
      let progress_data;

      api.answer = function (answer) {
        const note = answer.id;
        const correct = note === current_note.note;
        console.log(correct, answer)
        //sendListToBackend([current_note, correct])
        //trialmananger.start();
      }

      api.setProgress = function (_progress_data) {
        progress_data = _progress_data;
      }


      function sortAndRandomizeByN() {
        console.log(progress_data)
        return progress_data.slice().sort((a, b) => {
          if (a.n !== b.n) {
            return a.n - b.n;
          }
          return Math.random() - 0.5;
        });
      }

      function parse_note(note) {
        let note_str = note['note'];
        note_str = note_str.charAt(0);
        switch (note['alter']) {
          case 1:
            note_str += '#';
            break;
          case -1:
            note_str += 'b';
            break;
          case 2:
            note_str += '##';
            break;
          case -2:
            note_str += 'bb';
            break;
        }
        note_str += '/' + note['octave'];
        return note_str;
      }

      api.start = function () {
        current_note = sortAndRandomizeByN()[0];
        const parsed_note = parse_note(current_note);
        document.current_note = parsed_note;
        updateNote(parsed_note);
      }


      return api;
    }());
  </script>
{% endblock content %}
