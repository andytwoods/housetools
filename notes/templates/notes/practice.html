{% extends 'base.html' %}
{% load static %}


{% block javascript %}
    {{ block.super }}
    <script src="{% static 'js/vexflow.js' %}"></script>
{% endblock javascript %}

{% block title %}
    {{ instrument }} note trainer{% if key %}, {{ key }}{% endif %}
{% endblock %}

{% block body %}

    <div id='error-message'
         class="position-fixed start-50 translate-middle-x text-center bg-danger text-white p-2 rounded shadow"
         style="z-index: 1050; top: 5%; display: none;">
        <h2>m i s t a k e</h2>
        <p id="correct-answer"></p>
    </div>

    <div class="card w-100 mw-md-75 mx-auto pb-5">
        <div class="card-header d-flex justify-content-between align-items-center">
            <h5>{{ instrument }} note trainer{% if key %}, {{ key }}{% endif %}</h5>
            <input type="range" id="instrument-input-position" class="form-range" style="width: 150px; display: none;"
                   min="0"
                   max="10">
        </div>
        <div class="card-body position-relative">
            <div id="counter" style="display: none" class="text-secondary position-absolute top-0 start-0 p-2 m-2">
                {% block see_results %}
                    {% if learningscenario_id %}
                        <a href="{% url 'learningscenario_graph' learningscenario_id=learningscenario_id %}"
                           class="btn text-start p-0 mx-0 text-secondary">Stop and see your results</a>
                    {% endif %}
                {% endblock see_results %}
                <br>
                <span id="counter-value"></span>
            </div>
            <div class="row mt-5 text-center {{ score_css }}">

                <div class="col-9 align-self-center text-center">

                    <div id="sheet"></div>
                </div>
                <div id="right-of-sheet-placeholder"></div>

            </div>
            {% include instrument_template %}

        </div>
    </div>

    {{ progress|json_script:"progress-data" }}


    <script>
        document.addEventListener("DOMContentLoaded", function () {
            getInstrumentData('{{ answers_json }}', function (_instrument_data) {
                document.instrument_data = _instrument_data;
            });
        });
    </script>

    <script>

        function sendResultsToBackend(data) {

            // Sending the POST request to the backend
            {% if package_id %}
                fetch("{% url 'practice-data' package_id=package_id %}", {
                    method: 'POST', // HTTP method
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': "{{ csrf_token }}"
                    },
                    body: JSON.stringify(data) // Convert the list to JSON format
                });
            {% endif %}

        }
    </script>
    <script>

        const stave_manager = (function () {
            let api = {};
            const VF = Vex.Flow;  // Reference VexFlow library
            const div = document.getElementById("sheet");
            const containerWidth = div.clientWidth;
            const staveWidth = 200; //

            // Initialize VexFlow renderer
            const renderer = new VF.Renderer(div, VF.Renderer.Backends.SVG);
            renderer.resize(containerWidth, 200);  // Resize the SVG

            const context = renderer.getContext();  // Get the rendering context

            const startX = (containerWidth - staveWidth) / 2; // Calculate the starting point for centering
            const stave = new VF.Stave(startX, 40, staveWidth);
            stave.addClef("{{ clef }}");
            stave.setContext(context); // Attach the context to the stave
            stave.draw(context);       // Draw the stave

            function calc_stem_direct(note_str) {
                const stave = '{{ clef }}';

                let middle_note, middle_octave;
                if (stave === 'treble') {
                    middle_note = "B";
                    middle_octave = 4;
                } else if (stave === 'bass') {
                    middle_note = 'D'
                    middle_octave = 3;
                } else {
                    throw new Error('stave not recognized: ' + stave);
                }

                const note_arr = note_str.split("/");
                const target_octave = parseInt(note_arr[1]);
                let target_note = note_arr[0];
                let target_accidental = '';

                if (target_note.indexOf('#') !== -1) {
                    target_accidental = '#';
                    target_note = target_note.replace('#', '');
                } else if (target_note.indexOf('b') !== -1) {
                    target_accidental = 'b';
                    target_note = target_note.replace('b', '');
                }

                const scale_order = 'CDEFGAB';
                const target_scale_index = scale_order.indexOf(target_note);
                const middle_scale_index = scale_order.indexOf(middle_note);

                if (target_octave > middle_octave) {
                    return -1;
                } else if (target_octave < middle_octave) {
                    return 1;
                }

                if (target_scale_index >= middle_scale_index) {
                    return -1;
                } else {
                    return 1;
                }
            }

            api.updateNote = function (newNote) {
                renderer.getContext().svg.innerHTML = "";

                stave.setContext(context);
                stave.draw();

                let noteX = staveWidth / 2;

                const stemDirection = calc_stem_direct(newNote);

                // Create and explicitly set the stem direction
                const note = new VF.StaveNote({
                    keys: [newNote],
                    duration: "q",
                    align_center: true,
                    stem_direction: stemDirection // Explicitly set the stem direction
                });

                const voice = new VF.Voice({num_beats: 1, beat_value: 4});
                voice.addTickables([note]);

                // Handle accidentals
                if (newNote.indexOf('#') !== -1 || newNote.indexOf('b') !== -1) {
                    VF.Accidental.applyAccidentals([voice], `D`);
                    noteX += 15;
                }

                // Format and draw the voice
                new VF.Formatter().joinVoices([voice]).format([voice], noteX);
                voice.draw(context, stave);
            };

            // Track DOM elements of feedback notes
            let feedbackNotes = [];

            api.feedback_note = function (note) {
                // Clear previously rendered red notes
                feedbackNotes.forEach(element => {
                    if (element instanceof Node) {
                        element.parentNode.removeChild(element); // Remove valid SVG nodes
                    }
                });
                feedbackNotes = []; // Reset the array

                // Set the context for the stave
                stave.setContext(context);
                stave.draw();

                // Set X positions for the red note to appear
                const firstNoteX = staveWidth / 2;
                let secondNoteX = firstNoteX + 75; // Adjust spacing as desired

                // Calculate the stem direction for the new note
                const stemDirection = calc_stem_direct(note);

                // Create the new red note
                const redNote = new VF.StaveNote({
                    keys: [note],
                    duration: "q",
                    align_center: true,
                    stem_direction: stemDirection,
                });

                // Set the note color to red
                redNote.setStyle({fillStyle: "red", strokeStyle: "red"});

                // Handle accidentals (if sharp '#' or flat 'b' is present)
                if (note.indexOf("#") !== -1 || note.indexOf("b") !== -1) {
                    redNote.addModifier(new VF.Accidental(note.includes("#") ? "#" : "b"), 0);
                    secondNoteX += 15; // Adjust X position for accidentals
                }

                // Create a voice and add the new red note
                const voice = new VF.Voice({num_beats: 1, beat_value: 4});
                voice.addTickables([redNote]);

                // Format and draw the voice
                const contextGroup = context.openGroup(); // Create a group to isolate this note in SVG
                new VF.Formatter().joinVoices([voice]).format([voice], secondNoteX);
                voice.draw(context, stave);
                context.closeGroup();

                // Track the SVG group as feedback note for future removal
                feedbackNotes.push(contextGroup);
            };


            return api;
        }());

    </script>

    <script>

        const countdown_manager = (function () {
            let api = {};

            let remainingTime;

            const counterSpan = document.getElementById("counter-value");

            api.start = function (durationInSeconds) {
                if (remainingTime !== undefined) return;
                if (durationInSeconds === undefined) durationInSeconds = 120;
                document.getElementById('counter').style.display = 'block';
                remainingTime = durationInSeconds;
                counterSpan.textContent = remainingTime;

                const intervalId = setInterval(() => {
                    remainingTime--;
                    counterSpan.textContent = remainingTime;

                    if (remainingTime <= 0) {
                        clearInterval(intervalId);
                        counterSpan.textContent = "Time's up!";
                    }
                }, 1000);

            }

            return api;
        }());

        document.addEventListener("DOMContentLoaded", function () {
            const progress_data = JSON.parse(
                document.getElementById('progress-data').textContent
            );
            if (progress_data !== undefined) {
                learning_manager.setProgress(progress_data);
                trial_manager.next();
            }
        });

        const trial_manager = (function () {
            let api = {};

            const ITI = 50;

            const timer = (function () {
                let api = {};
                let start = undefined;

                api.start = function () {
                    start = performance.now();
                }
                api.stop = function () {
                    const rt = performance.now() - start;
                    return rt.toFixed(0)
                }

                return api;
            }());

            const error_message_manager = (function () {
                let api = {};
                let callback;
                const error_message_el = document.getElementById('error-message');
                const correct_answer_el = document.getElementById('correct-answer');

                api.stop = function () {
                    error_message_el.style.display = 'none';
                    callback();
                    callback = undefined;
                }

                api.start = function (message, _callback) {
                    callback = _callback;
                    correct_answer_el.innerText = message;
                    error_message_el.style.display = 'block';
                }

                return api;
            }());


            let locked = false;

            api.answer = function (answer, mistake_message) {
                if (locked) {
                    error_message_manager.stop();
                    return;
                }

                locked = true;
                const rt = timer.stop();
                learning_manager.update_data(rt, answer);

                // this is NOT RT. Rather top left corner countdown.
                countdown_manager.start();

                const pruned_progress_data = learning_manager.data_for_backend();
                sendResultsToBackend(pruned_progress_data);

                if (answer === true) {
                    setTimeout(function () {
                        api.next();
                        locked = false;
                    }, ITI);
                } else error_message_manager.start(mistake_message, function () {
                    api.next();
                    locked = false;
                });
            }

            function parse_note(note) {
                let note_str = note['note'];
                note_str = note_str.charAt(0);
                switch (note['alter']) {
                    case 1:
                        note_str += '#';
                        break;
                    case -1:
                        note_str += 'b';
                        break;
                    case 2:
                        note_str += '##';
                        break;
                    case -2:
                        note_str += 'bb';
                        break;
                }
                note_str += '/' + note['octave'];
                return note_str;
            }

            api.next = function () {
                const next_note = learning_manager.next_note();
                const parsed_note = parse_note(next_note);
                document.current_note = parsed_note;
                timer.start();
                stave_manager.updateNote(parsed_note);
            }

            return api;
        }());

        const learning_manager = (function () {
            let api = {};

            const level = '{{ level }}';

            let current_note;
            let progress_data;


            {% if level == 'beginner' %}

                const beginner_manager = (function () {
                    let api = {};

                    api.next_note = function () {
                        console.log(progress_data);

                        const countNs = progress_data.reduce((sum, item) => sum + item.n, 0);
                        const countCorrects = progress_data.reduce((sum, item) => {
                            return sum + item.correct.filter(value => value === true).length;
                        }, 0);
                        const percentageCorrect = countCorrects / countNs * 100;

                        console.log(countNs, countCorrects, percentageCorrect)
                        return progress_data[0];
                    }

                    return api;

                }());
            {% endif %}


            api.setProgress = function (_progress_data) {
                progress_data = _progress_data;
                progress_data.forEach(note => {
                    if (!note['reaction_time_log']) note['reaction_time_log'] = [];
                    if (!note['correct']) note['correct'] = [];
                })
            }

            function sortAndRandomizeByN() {
                return progress_data.slice().sort((a, b) => {
                    if (a.n !== b.n) {
                        return a.n - b.n;
                    }
                    return Math.random() - 0.5;
                });
            }

            api.next_note = function () {
                {% if level == 'beginner' %}
                    current_note = beginner_manager.next_note();
                {% else %}
                    current_note = sortAndRandomizeByN()[0];
                {% endif %}

                return current_note;
            }

            api.data_for_backend = function () {
                return progress_data.filter(note => note['n'] > 0);
            }

            api.update_data = function (rt, answer) {
                current_note['reaction_time_log'].push(rt);
                current_note['correct'].push(answer);
                current_note['n'] += 1;
            }

            return api;
        }());
    </script>
{% endblock body %}
