{% load static %}
{% block button_css %}
  <style>
    .input-button {
      position: relative;
      background-color: white; /* Default white background */
      color: black; /* Default black text */
      border: 2px solid black; /* Optional: Add a black border */
    }

    .valve {
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.4), /* Standard shadow */ inset 0 1px 2px rgba(255, 255, 255, 0.6); /* Inner sheen shadow */
      border-radius: 50%;
      width: 90px;
      height: 90px;
    }

    .active {
      background-color: black !important;
      color: white !important;
    }
  </style>
{% endblock button_css %}

<div class="row w-100 justify-content-center text-center mt-auto">
  <div class="col-12 w-100 text-center">
    <button class="btn btn-secondary input-button btn-lg w-100" id="answer" data-valve="answer">Buzz</button>
  </div>
</div>

<div id='trumpet-right' class="position-absolute">
  {% block keys %}
    <button class="valve rounded-pill input-button my-3 p-4 trumpet-b3 position-absolute" data-valve="3">3</button>
    <button class="valve rounded-pill input-button my-3 p-4 trumpet-b2 position-absolute" data-valve="2">2</button>
    <button class="valve rounded-pill input-button my-3 p-4 trumpet-b1 position-absolute" data-valve="1">1</button>
  {% endblock keys %}
</div>

{% block instrument_modify %}
  <script>
    (function () {
      // Get the container for the valves
      const valves_container = document.getElementById('trumpet-right');
      const valves = valves_container.children;

      const gap = 10;

      // Set up the instrument input position element
      const instrument_input_tilt = document.getElementById('instrument-input-tilt');
      const instrument_input_vertical = document.getElementById('instrument-input-vertical');
      const instrument_input_horizontal = document.getElementById('instrument-input-horizontal');
      const instrument_input_separation = document.getElementById('instrument-input-separation');
      const instrument_input_reset = document.getElementById('reset-button');

      instrument_input_tilt.style.display = 'block';
      instrument_input_tilt.addEventListener('input', adjust_valves_tilt);
      instrument_input_vertical.addEventListener('input', adjust_valves_vertical);
      instrument_input_horizontal.addEventListener('input', adjust_valves_horizontal);
      instrument_input_separation.addEventListener('input', adjust_valves_separation);
      instrument_input_reset.addEventListener('click', reset_valves);

// Store the initial vertical and horizontal positions of all valves
      // Store the initial vertical and horizontal positions of all valves
      const initialValvePositions = [...valves].map(valve => ({
        top: parseInt(valve.style.top || '0'),
        right: parseInt(valve.style.right || '0'),
      }));

// Track user adjustments separately: vertical, horizontal, tilt, and separation
      let verticalOffset = 0;
      let horizontalOffset = 0; // Controlled by the horizontal input range (0–100)
      let tiltAngle = 0;        // Controlled by the tilt input range (0–100)
      let separationOffset = 0; // Added to control spacing adjustments

// Store the initial separation based on valve dimensions (constant gap between valves)
      const initialSeparation = valves[0].offsetWidth + gap; // Base separation = valve width + gap

// Define the minimum horizontal distance from the right (0 on horizontal range input)
      const minimumHorizontalDistance = 50; // Minimum distance (in pixels) from the right side

// Maximum tilt angle in degrees (maps directly to slider max value of 100)
      const maxTiltAngle = 90; // Adjust this value for a different maximum tilt

// Adjust all valves' vertical positions
      function adjust_valves_vertical(event) {
        verticalOffset = event ? parseInt(event.target.value * 4) : 0;
        update_valve_positions();
      }

// Adjust all valves' horizontal positions
      function adjust_valves_horizontal(event) {
        // Horizontal input defines the offset relative to the minimum horizontal distance
        horizontalOffset = event ? parseInt(event.target.value * 4) : 0;
        update_valve_positions();
      }

// Adjust all valves' tilt positions
      function adjust_valves_tilt(event) {
        // Map the slider input (0–100) to the tilt angle (0–maxTiltAngle)
        tiltAngle = event ? (parseInt(event.target.value) / 100) * maxTiltAngle : 0;
        update_valve_positions();
      }

// Adjust the separation of the valves
      function adjust_valves_separation(event) {
        separationOffset = event ? parseInt(event.target.value) : 0;
        update_valve_positions();
      }

// Function to dynamically calculate and update valve positions
      function update_valve_positions() {
        // Current separation is the initial separation plus the offset
        const currentSeparation = initialSeparation + separationOffset;

        for (let i = 0; i < valves.length; i++) {
          // Initial fixed positions for each valve
          const initialTop = initialValvePositions[i].top;
          const initialRight = initialValvePositions[i].right;

          // Calculate tilt offsets (based on angle and current separation)
          const angleInRadians = (Math.PI / 180) * tiltAngle; // Map tilt angle to radians
          const tiltHorizontalOffset = i * currentSeparation * Math.sin(angleInRadians); // Opposite side
          const tiltVerticalOffset = i * currentSeparation * Math.cos(angleInRadians);   // Adjacent side

          // Combine the initial positions with all offsets (vertical, tilt, horizontal, and separation)
          let computedRight = minimumHorizontalDistance + horizontalOffset + tiltHorizontalOffset; // Start from minimum
          const computedTop = initialTop + verticalOffset + tiltVerticalOffset;

          // Apply the computed positions to the valve
          valves[i].style.right = `${computedRight}px`;
          valves[i].style.top = `${computedTop}px`;
        }
      }

      function reset_valves() {
        // Reset the slider values to their default
        instrument_input_tilt.value = 0; // Reset tilt slider
        instrument_input_vertical.value = 0; // Reset vertical slider
        instrument_input_horizontal.value = 0; // Reset horizontal slider
        instrument_input_separation.value = 0; // Reset separation slider

        // Reset the tracked variables for offsets
        verticalOffset = 0;
        horizontalOffset = 0;
        tiltAngle = 0;
        separationOffset = 0;

        // Reset the valve positions to their initial state
        update_valve_positions();
      }

      let ux = JSON.parse(
      document.getElementById('ux-data').textContent
    )

// Initial placement of the valves
      update_valve_positions();
      // Apply styles and transitions to the container
      valves_container.style.opacity = '0';
      valves_container.style.display = 'block';

      setTimeout(function () {
        valves_container.style.transition = 'opacity 100ms ease-in';
        valves_container.style.opacity = '1';
      }, 200);
    })();
  </script>
{% endblock instrument_modify %}


<script>
  const orientation_manager = (function () {
    let api = {};
    let placeholder, trumpet_right, trumpet_bottom;

    function setup() {
      if (placeholder) return
      placeholder = document.getElementById('right-of-sheet-placeholder');
      trumpet_right = document.getElementById('trumpet-right');
      trumpet_bottom = document.getElementById('trumpet-bottom');

      placeholder.parentElement.replaceChild(trumpet_right, placeholder);
    }

    api.align_right = function () {
      setup();
      // note that we unhide the below when we reposition the valves vertically
      //trumpet_right.style.display = 'block';
      //trumpet_bottom.style.display = 'none';
    }

    api.align_bottom = function () {
      setup();
      //trumpet_right.style.display = 'none';
      //trumpet_bottom.style.display = 'block';
    }

    return api;
  }())
  orientation_manager.align_right();
</script>

{% block constants %}
  <script>
    window.keys = '123'
    window.nothing_selected = 'all up!'
    window.error_message = 'You pressed'
  </script>
{% endblock constants %}

<script>
  const instrument_manager = (function () {
        let api = {};

        let keys_pressed_by_finger = [];
        document.addEventListener('keydown', function (event) {
          if (keys_pressed_by_finger.indexOf(event.key) !== -1) return
          keys_pressed_by_finger.push(event.key);
          buttonlogic(event.key);
        });
        document.addEventListener('keyup', function (event) {
          keys_pressed_by_finger.splice(keys_pressed_by_finger.indexOf(event.key), 1);
        });

        document.querySelectorAll('.input-button').forEach((button) => {

          button.addEventListener('pointerdown', () => {
            buttonlogic(button.dataset.valve); // Trigger button logic
          });

        });

        function buttonlogic(key) {
          if (window.keys.indexOf(key) !== -1) {
            button_state(key);
          } else if (key === 'answer' || key === ' ') {
            answered();
          }
        }


        function button_state(key) {
          let el = 'trumpet-b' + key;
          const elements = Array.from(document.getElementsByClassName(el));

          elements.forEach(el => {
              if (el.classList.contains('active')) {
                el.classList.remove('active');
              } else {
                el.classList.add('active');
              }
            }
          )
        }

        function reset_valves() {
          Array.from(document.getElementsByClassName('valve')).forEach(function (el) {
            el.classList.remove('active');
          })
        }

        function answered() {

          const buttons = document.getElementsByClassName('input-button');
          var buttons_down = [];
          for (var i = 0; i < buttons.length; i++) {
            if (buttons[i].classList.contains('active')) {
              const valve = buttons[i].dataset.valve;
              if (buttons_down.indexOf(valve) === -1) buttons_down.push(valve);
            }
          }
          reset_valves();

          buttons_down.sort();

          const keys_pressed = buttons_down.join('+') || '';
          const correct_keys = getCorrectKeysPressed();
          const correct = correct_keys.indexOf(keys_pressed) !== -1;

          let error_message;
          if (!correct) {
            error_message = correct_keys.join(", ");
            if (error_message.length === 0) error_message = window.nothing_selected
            error_message = "Correct answer: " + error_message + '\n' + window.error_message + ': '
            if (keys_pressed.length > 0) {
              error_message += keys_pressed;
            } else error_message += window.nothing_selected;
          }
          trial_manager.answer(correct, error_message);
        }

        function getCorrectKeysPressed() {
          let current_note = document.current_note;
          if (current_note in document.instrument_data) return document.instrument_data[current_note];
          const equiv_notes = getEnharmonicEquivalents(current_note);
          for (const equiv_note of equiv_notes) {
            if (equiv_note in document.instrument_data) return document.instrument_data[equiv_note];
          }
          throw new Error("No correct answer found for note " + current_note + ", for trumpet");
        }

        return api;
      }

      ()
    )
  ;
</script>

<script>
  window.tutorial_instrument_specific_steps = [{
    popover: {
      title: "Trumpet valves",
      description: "Pretend you are holding a trumpet. Press down the correct valves."
    }
  },
    {
      popover: {
        title: "Buzz!",
        description: "Press 'buzz' to play the note."
      }
    },
  ]
</script>
